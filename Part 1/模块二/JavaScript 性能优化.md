# JavaScript 性能优化

## 内存管理

- 内存：由可读写单元组成，表示一片可操作空间
- 管理：人为的去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请空间、使用空间、释放空间
- 管理流程：申请 - 使用 - 释放

```js
// memory management
// 申请
let obj = {}
// 使用
obj.name = 'lg'
// 释放
obj = null
```

## 垃圾回收与常见GC算法

### JavaScript 中的垃圾回收

- JavaScript 中内存管理是自动的
- 对象不再被引用时是垃圾
- 对象不能从根上访问到时是垃圾

JavaScript 中的可达对象：

- 可以访问到的对象就是可达对象（引用、作用域链）
- 可达的标准就是从根出发是否能够被找到
- JavaScript 中的根就可以理解为是全局变量对象

```js
// 引用 reference
let obj = { name: 'xm' }
let ali = obj
obj = null
// 可达对象
function objGroup(obj1, obj2) {
  obj1.next = obj2
  obj2.prev = obj1
  return {
    o1: obj1,
    o2: obj2
  }
}
let obj = objGroup({ name: 'obj1' }, { name: 'obj2' })
console.log(obj)
// delete obj.o1
// delete obj.o2.prev
// obj1 不可达（垃圾）
```

### GC 算法介绍

> GC 定义与作用：
>
> - GC 就是垃圾回收机制的简写
> - GC可以找到内存中的垃圾、并释放和回收空间

GC 里的垃圾是什么：程序中不再需要使用对象

GC 算法：

- GC 是一种机制，垃圾回收器完成具体的工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则

常见 GC 算法：

- 引用计数
- 标记清除
- 标记整理
- 分代回收

### 引用计数算法实现原理

- 核心思想：设置引用数，判断当前引用数是否为 0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为 0 时立即回收

引用计数算法优点：

- 发现垃圾时立即回收
- 最大限度减少程序暂停

引用计数算法缺点：

- 无法回收循环引用的对象
- 时间开销大

### 标记清除算法实现原理

- 核心思想：分标记和清除两个阶段完成
- 遍历所有对象找标记活动对象
- 遍历所有对象清除没有标记对象
- 回收相应的空间

标记清除算法优点：

- 可以回收循环引用的的对象

标记清除算法缺点：

- 容易产生碎片化空间，浪费空间
- 不会立即回收垃圾对象

### 标记整理算法实现原理

- 标记整理可以看作是标记清除的增强
- 标记阶段的操作和标记清除一致
- 清除阶段会执行整理，移动对象位置

## V8引擎的垃圾回收

### 认识 V8

> - V8 是一款主流的 JavaScript 执行引擎
> - V8 采用即时编译
> - V8 内存设限

### V8 垃圾回收策略

- 采用分代回收的思想
- 内存分为新生代、老生代
- 针对不同对象采用不同算法

V8 中常用的 GC 算法：

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

###V8 如何回收新生代对象

V8 内存分配

- V8 内存空间一分为二
- 小空间用于存储新生代对象 (32M | 16M)
- 新生代指的是存活时间较短的对象

新生代对象回收实现：

- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为两个等大小空间
- 使用空间为 From，空闲空间为 To
- 活动对象存储于  From 空间
- 标记整理后将活动对象拷贝至 To
- From 与 To 交换空间完成释放

回收细节说明：

- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动至老生代
- 一轮 GC 还存活的新生代需要晋升
- To 空间的使用率超过 25%

### V8 如何回收老生代对象

老生代对象：

- 老生代对象存放在右侧老生代区域
- 64位操作系统1.4G，32位操作系统700M
- 老生代对象就是指存活时间较长的对象

老生代对象回收实现：

- 主要采用标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化
- 采用增量标记进行效率优化

细节对比：

- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不适合复制算法

## Performance 工具

### Performance 工具介绍

- GC 的目的是为了实现内存空间的良性循环
- 良性循环的基石是合理使用
- 时刻关注才能确定是否合理
- Performance 提供多种监控方式

### 内存问题的体现

- 页面出现延迟加载或经常性暂停
- 页面持续性出现糟糕的性能
- 页面的性能随时间延长越来越差

### 监控内存的几种方式

界定内存问题的标准：

- 内存泄露：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析

监控内存方式：

- 浏览器任务管理器
- Timeline 时序图记录
- 堆快照查找分离 DOM
- 判断是否存在频繁的垃圾回收

## 代码优化

精准测试 JavaScript 性能

- 本质上就是采集大量的执行样本进行数学统计和分析
- 使用基于 Benchmark.js 的 https://jsperf.com/ 完成

### 慎用全局变量

- 全局变量定义在全局执行上下文，是所有作用域链的顶端
- 全局执行上下文一直存在于上下文之心栈，直到程序退出
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

### 缓存全局变量

> 将使用中无法避免的全局变量缓存到局部

### 通过原型对象添加新增方法

> 在原型对象上新增实例对象需要的方法

### 避开闭包陷阱

闭包：

- 闭包是一种强大的语法
- 闭包使用不当很容易出现内存泄露
- 不要为了闭包而闭包

### 避免属性访问方法使用

JavaScript 中的面向对象

- JS 不需属性的访问方法，所有属性都是外部可见的
- 使用属性访问方法只会增加一层重定义，没有访问的控制力

### For 循环优化

```js
let arr = []
arr[10000] = 'icode'
for(let i = arr.length; i; i--) {
  console.log(arr[i])
}
```

### 采用最优循环方式

> forEach > for > for ... in

### 文档碎片优化节点添加

> 节点的添加操作必然会有回流和重绘
>
> `document.createDocumentFragment()`

### 克隆优化节点操作

> `cloneNode()`

### 直接量替换 Object 操作

```js
const a = [1, 2, 3] 
```

